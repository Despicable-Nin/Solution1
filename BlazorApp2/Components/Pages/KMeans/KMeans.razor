@page "/datamining"
@rendermode InteractiveServer

@using BlazorApp2.Data
@using BlazorApp2.Helpers
@using BlazorApp2.Services
@using BlazorApp2.Services.Clustering
@using BlazorApp2.Services.Crimes
@using BlazorApp2.Services.Enumerations
@using BlazorApp2.Services.Geocoding
@using System.Collections.Concurrent
@inject IClusteringService ClusteringService
@inject ICrimeService CrimeService
@inject IEnumeration EnumService
@inject NominatimGeocodingService GeocodingService

<h3>K-Means Clustering Results</h3>
<div class="container">
    <div class="row">
        <div class="col-6 col-sm-12 mb-3">
            <div class="form-group">
                <label for="numberOfClusters">Number of Clusters</label>
                <div class="input-group">
                    <input type="number" class="form-control col-sm-3" id="numberOfClusters" @bind="NumberOfCluster" placeholder="Number of cluster" min="3" aria-label="Number of cluster" aria-describedby="basic-addon2">
                    <div class="input-group-append">
                        <button class="btn btn-primary" @onclick="PerformClustering">Perform Clustering</button>
                        <button class="btn btn-danger" @onclick="DeleteAllClusters" disabled="@IsLoading">Delete All Clusters</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-6 col-sm-12">
            <div class="form-check checkbox-aligner">
                <input class="form-check-input mb-2" type="checkbox" id="showCheckboxes" @bind="ShowCheckboxes">
                <label class="form-check-label" for="showCheckboxes">&nbsp;Hide/Show Cluster Properties</label>
            </div>
        </div>
    </div>

    <hr />
    <div class="checkbox-container" style="@(ShowCheckboxes ? "" : "display: none;")">
        @foreach (var property in FlatClusterProperties)
        {
            <div class="checkbox-item">
                <input type="checkbox" @bind="@SelectedProperties[property]" /> @property
            </div>
        }
    </div>
</div>



<hr />
@if (IsLoading)
{
    <div class="text-center">
        <div class="spinner-border" role="status">
            <span class="sr-only">Loading...</span>
        </div>
        <p><em>Loading data, please wait...</em></p>
    </div>
}
else if (ClusterResults != null)
{
    <table class="table">
        <thead>
            <tr>
                <th>Crime(s)</th>
                <th>Latitude</th>
                <th>Longitude</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var result in ClusterResults)
            {
                <tr>
                    <td>@result.Count</td>
                    <td>@result.Latitude</td>
                    <td>@result.Longitude</td>
                </tr>
            }
        </tbody>
    </table>
}


    <div class="container">
        <OpenStreetMap Style="height:480px; width:640px" Zoom="18" Center="new Coordinate(initialLongitude, initialLatitude)">

            <Features>
                @foreach (var cluster in ClusterResults)
                {
                    <Marker Type="MarkerType.MarkerPin" Coordinate="new Coordinate(@cluster.Longitude, @cluster.Latitude)"></Marker>
                }
            </Features>
        </OpenStreetMap>
    </div>


<style>
    .checkbox-container {
        display: flex;
        flex-wrap: wrap; /* Allow items to wrap into the next line */
        gap: 20px; /* Space between checkbox items */
        max-height: 200px; /* Set a maximum height for the container */
        overflow-y: auto; /* Enable vertical scrollbar if content overflows */
    }

    .checkbox-item {
        flex: 1 0 30%; /* Make each item take up to 30% of the container width */
        min-width: 200px; /* Minimum width to ensure they don’t get too small */
    }

    .checkbox-aligner {
        display: flex;
        align-items: center;
    }
</style>

@code {
    private bool ShowCheckboxes = true;
    private bool IsLoading = false;
    private int SelectedCount { get; set; } = 0;
    private int NumberOfCluster { get; set; } = 3;

    private string[] FlatClusterProperties { get; set; } = [];
    private Dictionary<string, bool> SelectedProperties { get; set; } = [];
    private List<ClusterResult>? ClusterResults = [];
    private List<SanitizedCrimeRecord> FlatClusterDump = [];


    private bool HasFlatClusters => FlatClusterDump.Count > 0;


    protected override void OnInitialized()
    {
        // Get the property names from the Crime class
        FlatClusterProperties = GenericHelper.GetProperties<SanitizedCrimeRecord>().Except(["Id"]).ToArray();

        var initialProperties = new[]{nameof(SanitizedCrimeRecord.CaseID),
        nameof(SanitizedCrimeRecord.CrimeType),
        nameof(SanitizedCrimeRecord.Latitude),
        nameof(SanitizedCrimeRecord.Longitude)};


        // Initialize the SelectedProperties dictionary
        foreach (var property in FlatClusterProperties)
        {
            SelectedProperties[property] = false; // All checkboxes start unchecked
            if (initialProperties.Contains(property))
            {
                SelectedProperties[property] = true; // CaseID is selected by default
            }

        }
    }

    private async Task PerformClustering()
    {

        IsLoading = true;

        FlatClusterDump = (await ClusteringService.GetFlatClustersAsync()).ToList();

        if (FlatClusterDump.Count == 0)
        {
            // Fetch data to transform
            var data = await CrimeService.GetCrimesAsync(1, int.MaxValue);
            var crimeMotives = await EnumService.GetCrimeMotives();
            var crimeTypes = await EnumService.GetCrimeTypes();
            var severities = await EnumService.GetSeverities();
            var precincts = await EnumService.GetPoliceDistricts();
            var weathers = await EnumService.GetWeatherConditions();

            var addressBook = new ConcurrentDictionary<string, (double Latitude, double Longitude)>();
            foreach (var crime in data.Crimes)
            {
                (double Latitude, double Longitude) result = (0D, 0D);
                if (addressBook.ContainsKey(crime.Address))
                {
                    result = addressBook.GetValueOrDefault(crime.Address);
                }
                else
                {
                    result = await GeocodingService.GetLatLongAsync(crime.Address);
                    addressBook.TryAdd(crime.Address, (result.Latitude, result.Longitude));
                    await Task.Delay(1000);
                }
            }

            // Save first -- generate a temporary data table
            foreach (var crime in data.Crimes)
            {
                var date = DateTime.Parse(crime.Date);
                var flatCluster = new SanitizedCrimeRecord
                    {
                        NearbyLandmarkLatitude = "0",
                        NearbyLandmarkLongitude = "0",
                        CaseID = crime.CaseID.ToString(),
                        CrimeType = crimeTypes.FirstOrDefault(x => x.Value == crime.Severity).Key.ToString(),
                        Date = date.Ticks.ToString(),
                        Time = crime.Time.Ticks.ToString(),
                        Latitude = addressBook.GetValueOrDefault(crime.Address).Latitude.ToString(),
                        Longitude = addressBook.GetValueOrDefault(crime.Address).Longitude.ToString(), // Corrected Longitude assignment
                        SeverityId = severities.FirstOrDefault(x => x.Value == crime.Severity).Key.ToString(),
                        VictimCount = crime.VictimCount.ToString(),
                        ArrestMade = crime.ArrestMade.ToString(),
                        ArrestDate = crime.ArrestDate,
                        ResponseTimeInMinutes = crime.ResponseTimeInMinutes.ToString(),
                        PoliceDistrictId = precincts.FirstOrDefault(x => x.Value == crime.PoliceDistrict).Key.ToString(),
                        WeatherConditionId = weathers.FirstOrDefault(x => x.Value == crime.PoliceDistrict).Key.ToString(),
                        CrimeMotiveId = crimeMotives.FirstOrDefault(x => x.Value == crime.PoliceDistrict).Key.ToString(),
                        RecurringIncident = crime.RecurringIncident.ToString(),
                        PopulationDensityPerSqKm = crime.PopulationDensityPerSqKm.ToString(),
                        UnemploymentRate = crime.UnemploymentRate,
                        MedianIncome = crime.MedianIncome,
                        ProximityToPoliceStationInKm = crime.ProximityToPoliceStationInKm,
                        StreetLightPresent = (crime.StreetLightPresent ? 1 : 0).ToString(),
                        CCTVCoverage = (crime.CCTVCoverage ? 1 : 0).ToString(),
                        AlcoholOrDrugInvolvement = (crime.AlcoholOrDrugInvolvement ? 1 : 0).ToString(),
                    };

                FlatClusterDump.Add(flatCluster);
            }

            await ClusteringService.AddFlatClusterRangeAsync(FlatClusterDump);
        }

        var features = SelectedProperties
        .Where(x => x.Value)
        .Where(x => x.Key != nameof(SanitizedCrimeRecord.CaseID))
        .Select(x => x.Key).ToArray();

        ClusterResults = ClusteringService.PerformKMeansClustering(FlatClusterDump, features, NumberOfCluster);
        IsLoading = false;
    }

    private async Task DeleteAllClusters()
    {
        IsLoading = true;

        // Call the delete method from the service
        await ClusteringService.DeleteAllFlatClustersAsync();

        // Optionally clear cluster results if needed
        ClusterResults = null;

        IsLoading = false;
    }
}
